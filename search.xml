<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【方法论】JS 模块化梳理</title>
    <url>/2023/03/11/MethodologyFrontendJSModularity%20/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：</p>
<ul>
<li>JS 模块化的前世今生（为什么要模块化）</li>
<li>JS 模块化的本质（如何实现模块化）</li>
</ul>
<h2 id="一、JS-模块化的前世今生"><a href="#一、JS-模块化的前世今生" class="headerlink" title="一、JS 模块化的前世今生"></a>一、JS 模块化的前世今生</h2><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3><p>大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。</p>
<p>此时的 js 代码的书写方式是，从上到下，简单明了，直到<code>ajax</code>出现。</p>
<h3 id="模块化萌芽"><a href="#模块化萌芽" class="headerlink" title="模块化萌芽"></a>模块化萌芽</h3><p>Google 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。</p>
<ol>
<li><code>全局变量污染</code><br>因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是我写的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是同事写的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;c.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;这里请不要改&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。</p>
<p><em>解决方案</em></p>
<p>解决方法之一是使用自执行函数包裹：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">myModule = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> id = <span class="string">&#x27;user_id&#x27;</span></span><br><span class="line">	...</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div>
<p>这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。</p>
<ol start="2">
<li><code>函数命名冲突</code><br>我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。</li>
</ol>
<p><em>解决方案</em></p>
<p>解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">MyNameSpace</span>.<span class="property">Utils</span>.<span class="title function_">format</span>()</span><br></pre></td></tr></table></figure></div>
<p>这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。</p>
<ol start="3">
<li><code>文件依赖混乱</code><br>文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入<code>&lt;script src=&quot;dialog&quot;&gt;</code>之前，需要先引入<code>&lt;script src=&quot;utils&quot;&gt;</code>，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。</li>
</ol>
<p><em>解决方案</em></p>
<p>这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">YUI</span>.<span class="title function_">add</span>(<span class="string">&#x27;my-module&#x27;</span>, <span class="keyword">function</span> (<span class="params">Y</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="string">&#x27;0.0.1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">requires</span>: [<span class="string">&#x27;node&#x27;</span>, <span class="string">&#x27;event&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。</p>
<p>在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。</p>
<h3 id="几种模块化规范"><a href="#几种模块化规范" class="headerlink" title="几种模块化规范"></a>几种模块化规范</h3><p>从以上的例子中可以观察到一些模块化所面临的难题：</p>
<ol>
<li>如何安全的包装一个模块（不污染模块外的代码）</li>
<li>如何定义模块的唯一标识（解决命名冲突）</li>
<li>如何优雅的暴露模块（不增加复杂依赖）</li>
<li>模块间互相引用的循环依赖问题</li>
</ol>
<p>在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules&#x2F;1.0 规范](<a class="link"   href="https://wiki.commonjs.org/wiki/Modules/1.0" >Modules&#x2F;1.0 - CommonJS Spec Wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)，首次定义了一个模块应该如何编写：</p>
<blockquote>
<ol>
<li>模块的标识应遵循的规则（书写规范）</li>
<li>定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API</li>
<li>如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖</li>
<li>如果引入模块失败，那么 require 函数应该报一个异常</li>
<li>模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。</li>
</ol>
</blockquote>
<p>一开始实现 Modules&#x2F;1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span>,i = <span class="number">0</span>, args = <span class="variable language_">arguments</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		sum += args[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>).<span class="property">add</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">increment</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">&#x27;increment&#x27;</span>).<span class="property">increment</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">inc</span>(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></div>
<p>相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：</p>
<ol>
<li>外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）</li>
<li>资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。<br>因为这些问题，社区中的主张分裂为 3 种，分别是</li>
</ol>
<ul>
<li>Modules&#x2F;1.x 派</li>
<li>Modules&#x2F;Async 派</li>
<li>Modules&#x2F;2.0 派</li>
</ul>
<p><code>Modules/1.x,CommonJS,browserify</code><br>这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 <a class="link"   href="https://wiki.commonjs.org/wiki/Modules/Transport" >Modules&#x2F;Transport 规范 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<code>browserify</code>是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。</p>
<p><code>Modules/Async,AMD,RequireJS</code><br>这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 <a class="link"   href="https://github.com/amdjs/amdjs-api/wiki/AMD-%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89" >AMD（Asynchronous Module Definition） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，根据 AMD 规范出现了<code>RequireJS</code>的实现，它的写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(id?, dependencies?, factory);</span><br><span class="line"></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;increment&#x27;</span>,[<span class="string">&#x27;math&#x27;</span>,<span class="string">&#x27;other&#x27;</span>],<span class="keyword">function</span>(<span class="params">math</span>)&#123;</span><br><span class="line">	<span class="comment">// 此时 math 和 other 模块内的代码已经执行完毕</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">val</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> math.<span class="title function_">add</span>(val,<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 即使 other 没有被使用到，other 还是被提前执行了</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		other.<span class="title function_">doSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>Modules/2.0 CMD Sea.js</code><br>这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 <a href="%5Bhttp://wiki.commonjs.org/wiki/Modules/Wrappings%5D(http://wiki.commonjs.org/wiki/Modules/Wrappings)">Modules&#x2F;Wrappings 规范</a>,<code>SeaJS</code>是它的一个实现。写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(factory);</span><br><span class="line"></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="variable language_">module</span></span>)&#123;</span><br><span class="line">	<span class="comment">// 就近原则，哪里使用哪里声明</span></span><br><span class="line">	<span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">		<span class="attr">increment</span>:<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> math.<span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：<code>AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。</code></p>
<p><code>ES6 Module</code><br>从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//increment.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">val</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么它和上面提到的几种模块化方案有哪些不同呢？</p>
<ol>
<li>动态只读引用<blockquote>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此</p>
</blockquote>
</li>
<li>编译时输出<blockquote>
<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。</p>
</blockquote>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>AMD&#x2F;CMD&#x2F;CommonJs 是 js 模块化开发的规范，对应的实现是 require.js&#x2F;sea.js&#x2F;Node.js，ES Module 是 ES6 在语言规范上的模块化实现。</li>
<li>CommonJS 主要针对服务端，AMD&#x2F;CMD&#x2F;ES Module 主要针对浏览器端，容易混淆的是 AMD&#x2F;CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。</li>
<li>AMD&#x2F;CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。</li>
<li>AMD&#x2F;CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。</li>
<li></li>
</ol>
<h2 id="二、模块化的本质"><a href="#二、模块化的本质" class="headerlink" title="二、模块化的本质"></a>二、模块化的本质</h2><blockquote>
<p>模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生模块模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moduleA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = <span class="string">&quot;another&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(another);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">        <span class="attr">doAnother</span>: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用模块内方法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title function_">moduleA</span>();</span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">// something</span></span><br><span class="line">foo.<span class="property">another</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 类型的模块</span></span><br><span class="line"><span class="comment">// var $ = window.jQuery()</span></span><br></pre></td></tr></table></figure></div>
<p>在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> another = <span class="string">&quot;another&quot;</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>)&#123;...&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>)&#123;...&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">doSomething</span>: doSomething,</span><br><span class="line">		<span class="attr">doAnother</span>: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
<p>这种形式避免了函数名冲突，并且实现了单例模式。</p>
<p>大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleCreater = (<span class="keyword">function</span> <span class="title function_">Manager</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 通过 define 方法定义模块</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">define</span>(<span class="params">id,deps,impl</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; deps.<span class="property">length</span>;i++)&#123;</span><br><span class="line">			<span class="comment">// 在这里解包依赖数组</span></span><br><span class="line">			deps[i] = modules[deps[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		modules[id] = impl.<span class="title function_">apply</span>(imply,deps);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">id</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> modules[id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">define</span>: define,</span><br><span class="line">		<span class="attr">get</span>: get</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《你不知道的 Javascript》（上卷）</li>
<li><a class="link"   href="https://www.cnblogs.com/lvdabao/p/js-modules-develop.html" >js 模块化历程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/moxiaowohuwei/p/8692359.html" >js 模块化编程之彻底弄懂 CommonJS 和 AMD&#x2F;CMD！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/seajs/seajs/issues/588" >前端模块化开发那点历史 · Issue #588 · seajs&#x2F;seajs (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/seajs/seajs/issues/269" >从 CommonJS 到 Sea.js · Issue #269 · seajs&#x2F;seajs (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端工程化</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】TypeScript 装饰器完全指南 _ Disenchanted</title>
    <url>/2022/11/02/ReprintTypscriptDecorator/</url>
    <content><![CDATA[<blockquote>
<p>原文转自：<a class="link"   href="https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/" >https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>装饰器让 TypeScript 的世界更好。 我们使用的许多库都基于这一强大特性构建，例如 <a class="link"   href="https://angular.io/" >Angular <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://nestjs.com/" >Nestjs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。 在这篇博客中我将介绍装饰器和它的许多细节。 我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。</p>
<p>装饰器本质上是一种特殊的函数被应用在于：</p>
<ol>
<li>类</li>
<li>类属性</li>
<li>类方法</li>
<li>类访问器</li>
<li>类方法的参数</li>
</ol>
<p>所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。 通过装饰器我们可以轻松实现 <a class="link"   href="https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" >代理模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来使代码更简洁以及实现其它一些更有趣的能力。</p>
<p>装饰器的语法十分简单，只需要在想使用的装饰器前加上<code>@</code>符号，装饰器就会被应用到目标上：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function simpleDecorator() &#123;</span><br><span class="line">  console.log(&#x27;---hi I am a decorator---&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@simpleDecorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>一共有 5 种装饰器可被我们使用：</p>
<ol>
<li>类装饰器</li>
<li>属性装饰器</li>
<li>方法装饰器</li>
<li>访问器装饰器</li>
<li>参数装饰器</li>
</ol>
<p>让我们来快速认识一下这五种装饰器：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@classDecorator</span><br><span class="line">class Bird &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  @propertyDecorator</span><br><span class="line">  name: string;</span><br><span class="line">  </span><br><span class="line">  @methodDecorator</span><br><span class="line">  fly(</span><br><span class="line">    </span><br><span class="line">    @parameterDecorator</span><br><span class="line">      meters: number</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  @accessorDecorator</span><br><span class="line">  get egg() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h2><p>装饰器只在解释执行时应用一次，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(C) &#123;</span><br><span class="line">  console.log(&#x27;apply decorator&#x27;)</span><br><span class="line">  return C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@f</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里的代码会在终端中打印<code>apply decorator</code>，即便我们其实并没有使用类 A。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>不同类型的装饰器的执行顺序是明确定义的：</p>
<ol>
<li>实例成员：</li>
</ol>
<p>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 2. 静态成员：<br>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 3. 构造器：参数装饰器 4. 类装饰器</p>
<p>例如，考虑以下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(key: string): any &#123;</span><br><span class="line">  console.log(&quot;evaluate: &quot;, key);</span><br><span class="line">  return function () &#123;</span><br><span class="line">    console.log(&quot;call: &quot;, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@f(&quot;Class Decorator&quot;)</span><br><span class="line">class C &#123;</span><br><span class="line">  @f(&quot;Static Property&quot;)</span><br><span class="line">  static prop?: number;</span><br><span class="line"></span><br><span class="line">  @f(&quot;Static Method&quot;)</span><br><span class="line">  static method(@f(&quot;Static Method Parameter&quot;) foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  constructor(@f(&quot;Constructor Parameter&quot;) foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @f(&quot;Instance Method&quot;)</span><br><span class="line">  method(@f(&quot;Instance Method Parameter&quot;) foo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @f(&quot;Instance Property&quot;)</span><br><span class="line">  prop?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>它将会打印出以下信息：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">evaluate:  Instance Method</span><br><span class="line">evaluate:  Instance Method Parameter</span><br><span class="line">call:  Instance Method Parameter</span><br><span class="line">call:  Instance Method</span><br><span class="line">evaluate:  Instance Property</span><br><span class="line">call:  Instance Property</span><br><span class="line">evaluate:  Static Property</span><br><span class="line">call:  Static Property</span><br><span class="line">evaluate:  Static Method</span><br><span class="line">evaluate:  Static Method Parameter</span><br><span class="line">call:  Static Method Parameter</span><br><span class="line">call:  Static Method</span><br><span class="line">evaluate:  Class Decorator</span><br><span class="line">evaluate:  Constructor Parameter</span><br><span class="line">call:  Constructor Parameter</span><br><span class="line">call:  Class Decorator</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>你也许会注意到执行实例属性<code>prop</code>晚于实例方法<code>method</code> 然而执行静态属性<code>static prop</code>早于静态方法<code>static method</code>。 这是因为对于属性 &#x2F; 方法 &#x2F; 访问器装饰器而言，执行顺序取决于声明它们的顺序。</p>
<p>然而，同一方法中不同参数的装饰器的执行顺序是相反的， 最后一个参数的装饰器会最先被执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(key: string): any &#123;</span><br><span class="line">  console.log(&quot;evaluate: &quot;, key);</span><br><span class="line">  return function () &#123;</span><br><span class="line">    console.log(&quot;call: &quot;, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  method(</span><br><span class="line">    @f(&quot;Parameter Foo&quot;) foo,</span><br><span class="line">    @f(&quot;Parameter Bar&quot;) bar</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里的代码打印出的结果为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">evaluate:  Parameter Foo</span><br><span class="line">evaluate:  Parameter Bar</span><br><span class="line">call:  Parameter Bar</span><br><span class="line">call:  Parameter Foo</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="多个装饰器的组合"><a href="#多个装饰器的组合" class="headerlink" title="多个装饰器的组合"></a>多个装饰器的组合</h2><p>你可以对同一目标应用多个装饰器。它们的组合顺序为：</p>
<ol>
<li>求值外层装饰器</li>
<li>求值内层装饰器</li>
<li>调用内层装饰器</li>
<li>调用外层装饰器</li>
</ol>
<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(key: string) &#123;</span><br><span class="line">  console.log(&quot;evaluate: &quot;, key);</span><br><span class="line">  return function () &#123;</span><br><span class="line">    console.log(&quot;call: &quot;, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @f(&quot;Outer Method&quot;)</span><br><span class="line">  @f(&quot;Inner Method&quot;)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里的代码打印出的结果为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">evaluate: Outer Method</span><br><span class="line">evaluate: Inner Method</span><br><span class="line">call: Inner Method</span><br><span class="line">call: Outer Method</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类型声明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ClassDecorator = &lt;TFunction extends Function&gt;</span><br><span class="line">  (target: TFunction) =&gt; TFunction | void;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>@参数：<ol>
<li><code>target</code>: 类的构造器。</li>
</ol>
</li>
<li>@返回：<br>如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。</li>
</ul>
<p>因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。</p>
<p>例如我们可以添加一个<code>toString</code>方法给所有的类来覆盖它原有的<code>toString</code>方法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Consturctor = &#123; new (...args: any[]): any &#125;;</span><br><span class="line"></span><br><span class="line">function toString&lt;T extends Consturctor&gt;(BaseClass: T) &#123;</span><br><span class="line">  return class extends BaseClass &#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">      return JSON.stringify(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@toString</span><br><span class="line">class C &#123;</span><br><span class="line">  public foo = &quot;foo&quot;;</span><br><span class="line">  public num = 24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new C().toString())</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>遗憾的是装饰器并没有类型保护，这意味着：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class="line"></span><br><span class="line">@Blah</span><br><span class="line">class Foo &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    return this.foo; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo().foo; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这是 <a class="link"   href="https://github.com/microsoft/TypeScript/issues/4881" >一个 TypeScript 的已知的缺陷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。 目前我们能做的只有额外提供一个类用于提供类型信息：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">  foo: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Blah</span><br><span class="line">class Foo extends Base &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    return this.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo().foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>类型声明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type PropertyDecorator =</span><br><span class="line">  (target: Object, propertyKey: string | symbol) =&gt; void;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>@参数：<ol>
<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
<li><code>propertyKey</code>: 属性的名称。</li>
</ol>
</li>
<li>@返回：<br>返回的结果将被忽略。</li>
</ul>
<p>除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。 例如我们可以写一个装饰器来给某些属性添加监听器。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function capitalizeFirstLetter(str: string) &#123;</span><br><span class="line">  return str.charAt(0).toUpperCase() + str.slice(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function observable(target: any, key: string): any &#123;</span><br><span class="line">  </span><br><span class="line">  const targetKey = &quot;on&quot; + capitalizeFirstLetter(key) + &quot;Change&quot;;</span><br><span class="line"></span><br><span class="line">  target[targetKey] =</span><br><span class="line">    function (fn: (prev: any, next: any) =&gt; void) &#123;</span><br><span class="line">      let prev = this[key];</span><br><span class="line">      Reflect.defineProperty(this, key, &#123;</span><br><span class="line">        set(next) &#123;</span><br><span class="line">          fn(prev, next);</span><br><span class="line">          prev = next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @observable</span><br><span class="line">  foo = -1;</span><br><span class="line"></span><br><span class="line">  @observable</span><br><span class="line">  bar = &quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line"></span><br><span class="line">c.onFooChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class="line">c.onBarChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class="line"></span><br><span class="line">c.foo = 100; </span><br><span class="line">c.foo = -3.14; </span><br><span class="line">c.bar = &quot;baz&quot;; </span><br><span class="line">c.bar = &quot;sing&quot;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>类型声明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type MethodDecorator = &lt;T&gt;(</span><br><span class="line">  target: Object,</span><br><span class="line">  propertyKey: string | symbol,</span><br><span class="line">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span><br><span class="line">) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>@参数：<ol>
<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
<li><code>propertyKey</code>: 属性的名称。</li>
<li><code>descriptor</code>: 属性的 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" >描述器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
</ol>
</li>
<li>@返回： 如果返回了值，它会被用于替代属性的描述器。</li>
</ul>
<p>方法装饰器不同于属性装饰器的地方在于<code>descriptor</code>参数。 通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。 例如我们可以给一些方法添加打印输入与输出的能力：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">  const original = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = function (...args) &#123;</span><br><span class="line">    console.log(&#x27;params: &#x27;, ...args);</span><br><span class="line">    const result = original.call(this, ...args);</span><br><span class="line">    console.log(&#x27;result: &#x27;, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @logger</span><br><span class="line">  add(x: number, y:number ) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line">c.add(1, 2);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h2><p>访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的 key 不同：</p>
<p>方法装饰器的描述器的 key 为：</p>
<ul>
<li><code>value</code></li>
<li><code>writable</code></li>
<li><code>enumerable</code></li>
<li><code>configurable</code></li>
</ul>
<p>访问器装饰器的描述器的 key 为：</p>
<ul>
<li><code>get</code></li>
<li><code>set</code></li>
<li><code>enumerable</code></li>
<li><code>configurable</code></li>
</ul>
<p>例如，我们可以将某个属性设为不可变值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function immutable(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">  const original = descriptor.set;</span><br><span class="line"></span><br><span class="line">  descriptor.set = function (value: any) &#123;</span><br><span class="line">    return original.call(this, &#123; ...value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  private _point = &#123; x: 0, y: 0 &#125;</span><br><span class="line"></span><br><span class="line">  @immutable</span><br><span class="line">  set point(value: &#123; x: number, y: number &#125;) &#123;</span><br><span class="line">    this._point = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get point() &#123;</span><br><span class="line">    return this._point;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line">const point = &#123; x: 1, y: 1 &#125;</span><br><span class="line">c.point = point;</span><br><span class="line"></span><br><span class="line">console.log(c.point === point)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h2><p>类型声明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ParameterDecorator = (</span><br><span class="line">  target: Object,</span><br><span class="line">  propertyKey: string | symbol,</span><br><span class="line">  parameterIndex: number</span><br><span class="line">) =&gt; void;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>@参数：<ol>
<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
<li><code>propertyKey</code>: 属性的名称 （注意是方法的名称，而不是参数的名称）。</li>
<li><code>parameterIndex</code>: 参数在方法中所处的位置的下标。</li>
</ol>
</li>
<li>@返回：<br>返回的值将会被忽略。</li>
</ul>
<p>单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。</p>
<p>对于一些复杂场景， 我们可能需要结合使用不同的装饰器。 例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。</p>
<p>我们可以用 3 个步骤来实现这个功能：</p>
<ol>
<li>标记需要检查的参数 （因为参数装饰器先于方法装饰器执行）。</li>
<li>改变方法的<code>descriptor</code>的<code>value</code>的值，先运行参数检查器，如果失败就抛出异常。</li>
<li>运行原有的接口实现。</li>
</ol>
<p>以下是代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Validator = (x: any) =&gt; boolean;</span><br><span class="line"></span><br><span class="line">const validateMap: Record&lt;string, Validator[]&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function typedDecoratorFactory(validator: Validator): ParameterDecorator &#123;</span><br><span class="line">  return (_, key, index) =&gt; &#123;</span><br><span class="line">    const target = validateMap[key as string] ?? [];</span><br><span class="line">    target[index] = validator;</span><br><span class="line">    validateMap[key as string] = target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validate(_: Object, key: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">  const originalFn = descriptor.value;</span><br><span class="line">  descriptor.value = function(...args: any[]) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    const validatorList = validateMap[key];</span><br><span class="line">    if (validatorList) &#123;</span><br><span class="line">      args.forEach((arg, index) =&gt; &#123;</span><br><span class="line">        const validator = validatorList[index];</span><br><span class="line"></span><br><span class="line">        if (!validator) return;</span><br><span class="line"></span><br><span class="line">        const result = validator(arg);</span><br><span class="line"></span><br><span class="line">        if (!result) &#123;</span><br><span class="line">          throw new Error(</span><br><span class="line">            `Failed for parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return originalFn.call(this, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isInt = typedDecoratorFactory((x) =&gt; Number.isInteger(x));</span><br><span class="line">const isString = typedDecoratorFactory((x) =&gt; typeof x === &#x27;string&#x27;);</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @validate</span><br><span class="line">  sayRepeat(@isString word: string, @isInt x: number) &#123;</span><br><span class="line">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class="line">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>正如例子中展示的， 对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。</p>
<p>严格地说，元数据和装饰器是 EcmaScript 中两个独立的部分。 然而，如果你想实现像是 <a class="link"   href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" >反射 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 这样的能力，你总是同时需要它们。</p>
<p>如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？ 或者说，能否只写一个检查器能够通过我们编写的 TS 类型声明来自动运行类型检查？</p>
<p>有了 <a class="link"   href="https://github.com/rbuckton/reflect-metadata" >reflect-metadata <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的帮助， 我们可以获取编译期的类型。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;reflect-metadata&#x27;;</span><br><span class="line"></span><br><span class="line">function validate(</span><br><span class="line">  target: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  descriptor: PropertyDescriptor</span><br><span class="line">) &#123;</span><br><span class="line">  const originalFn = descriptor.value;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  const designParamTypes = Reflect</span><br><span class="line">    .getMetadata(&#x27;design:paramtypes&#x27;, target, key);</span><br><span class="line"></span><br><span class="line">  descriptor.value = function (...args: any[]) &#123;</span><br><span class="line">    args.forEach((arg, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      const paramType = designParamTypes[index];</span><br><span class="line"></span><br><span class="line">      const result = arg.constructor === paramType</span><br><span class="line">        || arg instanceof paramType;</span><br><span class="line"></span><br><span class="line">      if (!result) &#123;</span><br><span class="line">        throw new Error(</span><br><span class="line">          `Failed for validating parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return originalFn.call(this, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  @validate</span><br><span class="line">  sayRepeat(word: string, x: number) &#123;</span><br><span class="line">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new C();</span><br><span class="line">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class="line">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>目前为止一共有三种编译期类型可以拿到：</p>
<ul>
<li><code>design:type</code>: 属性的类型。</li>
<li><code>desin:paramtypes</code>: 方法的参数的类型。</li>
<li><code>design:returntype</code>: 方法的返回值的类型。</li>
</ul>
<p>这三种方式拿到的结果都是构造函数（例如<code>String</code>和<code>Number</code>）。规则是：</p>
<ul>
<li>number -&gt; <code>Number</code></li>
<li>string -&gt; <code>String</code></li>
<li>boolean -&gt; <code>Boolean</code></li>
<li>void&#x2F;null&#x2F;never -&gt; <code>undefined</code></li>
<li>Array&#x2F;Tuple -&gt; <code>Array</code></li>
<li>Class -&gt; 类的构造函数</li>
<li>Enum -&gt; 如果是纯数字枚举则为<code>Number</code>, 否则是 <code>Object</code></li>
<li>Function -&gt; <code>Function</code></li>
<li>其余都是<code>Object</code></li>
</ul>
<p>现在我们可以对于何时使用装饰器得出结论， 在阅读上面的代码中你可能也有所感觉。</p>
<p>我将例举一些常用的使用场景：</p>
<ul>
<li>Before&#x2F;After 钩子。</li>
<li>监听属性改变或者方法调用。</li>
<li>对方法的参数做转换。</li>
<li>添加额外的方法和属性。</li>
<li>运行时类型检查。</li>
<li>自动编解码。</li>
<li>依赖注入。</li>
</ul>
<p>我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】01，作用域与闭包</title>
    <url>/2021/02/23/someInterestingQuestions01/</url>
    <content><![CDATA[<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i&#x27;</span>,i)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q1.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：异步代码会在同步代码执行完毕后执行</p>
<p><code>分析</code>：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5</p>
<p><strong>解决方案一：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code> 结果</code>：1 秒后连续打印 0 1 2 3 4 </p>
<p><code>原因</code>：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5</p>
<p><strong>解决方案二：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="title function_">setTimeourt</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：1 秒后连续打印 0 1 2 3 4</p>
<p><code>原因</code>：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<hr>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="title class_">Foo</span>(),</span><br><span class="line">    f2 = <span class="title class_">Foo</span>();</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q2.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：</p>
<p>第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i&#x3D;1；</p>
<p>第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i&#x3D;2；</p>
<p>第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。</p>
<hr>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 类变量 a</span></span><br><span class="line">  <span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例变量 a，每个实例都有一个</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例变量 a，所有实例共享一个</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类变量 a</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">obj.<span class="title function_">a</span>();</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q3.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：</p>
<p>打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。</p>
<p>打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。</p>
<p>打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。</p>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Vue Composition API</title>
    <url>/2022/05/02/ReprintVueCompositionAPI/</url>
    <content><![CDATA[<blockquote>
<p>原文转自：<a class="link"   href="https://zhuanlan.zhihu.com/p/408272742" >https://zhuanlan.zhihu.com/p/408272742 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class 完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中<strong>提取状态逻辑</strong>的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。</p>
<p>后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。</p>
<p>接下来让我们抛开 React，来看看 Composition API 都有哪些内容。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>1.1 什么是 Composition API ？</strong></p>
<p>Vue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。</p>
<p><strong>1.2 基本例子</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg"
                     
                ></p>
<p>我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 <code>setup</code> 函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 <code>data</code> 或者 <code>methods</code> 中没有什么区别。</p>
<p>当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 <code>this.xx</code> 访问到 <code>setup</code> 返回的变量。</p>
<p>❓ 如果只是把代码迁移到 <code>setup</code> 函数中，变成一长条的面条式代码，有什么意义呢</p>
<p><strong>1.3 更进一步的例子</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg"
                     
                ></p>
<p>这一次我们将 <code>setup</code> 中的代码进一步抽离，拆出了 <code>useMouse</code> 组合函数，里面封装了对鼠标位置的监听逻辑。<code>useMouse</code> 只需要将要暴露给组件的状态（<code>x</code>、<code>y</code>）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。</p>
<p>对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 <code>useMouse</code> 拿到 <code>x</code>、<code>y</code> 即可。</p>
<p>❓ 这些我用 Mixins 也能实现呀</p>
<p><strong>1.4 更更进一步的例子</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg"
                     
                ></p>
<p>首先我们通过模板来理解 <code>useDark</code> 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 <code>useToggle</code> 来快速得到一个 toggle 函数。</p>
<p>然后观察 <code>useDark</code>，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 <code>usePreferredDark</code> 和 <code>useLocalStorage</code> 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。</p>
<p>其中的组合函数调用关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg"
                     
                ></p>
<p>组合函数的底层又依赖了其他组合函数，比如 <code>useLocalStorage</code> 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的 <code>useStorage</code>，<code>usePreferredDark</code> 依赖封装了 <code>window.matchMedia</code> 逻辑的 <code>useMediaQuery</code>。它们最后又都通过 <code>useEventListener</code> 来做状态改变的响应，并且能自动卸载。</p>
<p>涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。</p>
<p>这个例子来源于 <a class="link"   href="https://link.zhihu.com/?target=https://github.com/vueuse/vueuse" >VueUse <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<p>当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel 组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。</p>
<h2 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、API</h2><p><strong>2.1 setup</strong></p>
<p><code>setup</code> 是组合式 API 的入口点，它的执行时机在 <code>beforeCreate</code> 和 <code>created</code>，并且只会执行一次。</p>
<p>所以我们不需要 <code>onBeforeCreate</code> 和 <code>onCreated</code>，这些钩子对应的代码应该直接在 <code>setup</code> 函数中编写。</p>
<p>它接收两个参数：</p>
<ol>
<li>响应式的 <code>props</code></li>
<li>非响应式的 <code>context</code>，包含：attrs、slots、emit</li>
</ol>
<p>它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。</p>
<p>如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。</p>
<p><strong>2.1.1 返回渲染函数</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg"
                     
                ></p>
<p>在 Babel Plugin 支持下可以返回 JSX：<a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/jsx/pull/142" >feat: add @vue&#x2F;composition-api support #142 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>2.1.2 getCurrentInstance</strong></p>
<p>如果确实需要访问组件实例，可以使用 <code>getCurrentInstance()</code>。</p>
<p>只能在 <code>setup</code>、生命周期钩子和组合函数中使用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg"
                     
                ></p>
<p><strong>2.2 reactive</strong></p>
<p>返回对象的响应式副本，相当于 <code>Vue.observable(obj)</code> 。</p>
<p>该响应式转换是 “深度转换”——它会影响嵌套对象传递的所有 property。</p>
<p>怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。</p>
<p><strong>2.2.1 无法代理原始值类型</strong></p>
<p>reactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。</p>
<p><strong>2.2.2 响应丢失</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg"
                     
                ></p>
<p><strong>2.3 ref</strong></p>
<p>接收一个值，返回的响应式且可变的包装对象。</p>
<p>它只有一个属性：<code>.value</code> ，该属性指向内部被包装的值。这个值可以直接修改。</p>
<p>我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref 来替我们做这件事。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg"
                     
                ></p>
<p><strong>2.3.1 自动解包（不需要加 .value 的情况）</strong></p>
<ol>
<li>ref 在模板中会自动解包</li>
</ol>
<p>2.<code>watch</code> 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg"
                     
                ></p>
<ol start="3">
<li>使用 reactive() &#x2F; readonly() 解包对象嵌套的 ref</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg"
                     
                ></p>
<p>但是从 <code>Array</code> 或原生集合类型如 <code>Map</code>访问 ref 时，不会进行解包。</p>
<p><strong>2.3.2 unref（ref 的反向操作）</strong></p>
<p>传入一个 ref，返回 <code>ref.value</code>，否则原样返回。</p>
<p>纠结是否需要加 <code>.value</code>（比如某个函数参数的类型是 <code>Ref&lt;number&gt; | number</code>）来取值，可以使用 unref 来解包。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg"
                     
                ></p>
<p><strong>2.3.3 重复使用已有 ref</strong></p>
<p>将一个 ref 传递给 <code>ref()</code> 构造函数，它会原样返回。</p>
<p>如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 <code>return ref(param)</code>，如果是 ref 则会复用，不是则返回一个新的 ref。</p>
<p><strong>2.3.4 可以使用 ES6 解构语法</strong></p>
<p>解构一个值是 ref 的对象不会丢失响应式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg"
                     
                ></p>
<p><strong>2.3.5 this.$refs 的解决方案</strong></p>
<p>在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。</p>
<p>由于是在虚拟 DOM 挂载 &#x2F; 打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg"
                     
                ></p>
<p><strong>2.4 toRefs</strong></p>
<p>将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。</p>
<p>可以用来解决 <code>reactive</code> 或者 <code>props</code> 在解构的时候丢失响应式的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg"
                     
                ></p>
<p><strong>2.5 computed</strong></p>
<p>接收 getter 函数，返回一个<strong>只读</strong>的响应式 ref 对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg"
                     
                ></p>
<p>如果参数是具有 get 和 set 函数的对象，返回的结果会是一个<strong>可写</strong>的响应式 ref 对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg"
                     
                ></p>
<p><strong>2.6 watch</strong></p>
<p>第一个参数接收数据源，可以是：</p>
<ul>
<li>getter 函数、ref</li>
<li>包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调）</li>
</ul>
<p>第二个参数是回调函数，在数据源变动的时候触发。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg"
                     
                ></p>
<p><strong>2.6.1 停止观察</strong></p>
<p><code>watch()</code> 返回一个停止观察的函数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg"
                     
                ></p>
<p>如果 <code>watch()</code> 是在一个组件的 <code>setup()</code> 或是生命周期函数中被调用的，那么该 watcher 会在当前组件被销毁时也一同被自动停</p>
<p><strong>2.6.2 清理 effect</strong></p>
<p>watcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。</p>
<p>有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。</p>
<p>调用这个函数可以注册一个清理函数，执行时机在：</p>
<ul>
<li>回调被下一次调用前</li>
<li>watcher 被停止前</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg"
                     
                ></p>
<h2 id="三、设计动机"><a href="#三、设计动机" class="headerlink" title="三、设计动机"></a>三、设计动机</h2><p><strong>3.1 从 Class API 到 Function API 再到 Composition API</strong></p>
<p>我们可以在 Vue RFC 中看到最初的 <a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/17" >Class API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 到 <a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/42" >Function-based Component API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 取其 FP 的精华，再到被修订为 <a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/78" >Composition API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 采用 Reactivity 的过程。</p>
<p><strong>3.2 解决了什么问题</strong></p>
<p>对比 2.x 对象式 API：</p>
<ul>
<li><p>极易复用。</p>
</li>
<li><p>状态可以从组件中拆出来放到组合函数中。</p>
</li>
<li><p>更清楚的逻辑。</p>
</li>
<li><p>代码可以按功能 &#x2F; 逻辑组织，而不是分散在各个选项中。</p>
</li>
<li><p>更好的 TypeScript 类型支持。</p>
</li>
<li><p>基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。</p>
</li>
<li><p>更小的打包体积。</p>
</li>
<li><p>基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API 的相关代码可以在最终打包时被移除。</p>
</li>
<li><p>同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性 &#x2F; 方法名却不可以。</p>
</li>
</ul>
<p><strong>3.3 对比 2.x 的复用模式</strong></p>
<p>Vue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括：</p>
<ul>
<li>Mixins</li>
<li>高阶组件 (Higher-order Components, aka HOCs)</li>
<li>Renderless Components （基于 scoped slots &#x2F; 作用域插槽封装逻辑的组件）</li>
</ul>
<p>总体来说，以上这些模式存在以下问题：</p>
<ul>
<li><p>模版中的数据来源不清晰。</p>
</li>
<li><p>举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。</p>
</li>
<li><p>使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。</p>
</li>
<li><p>命名空间冲突。</p>
</li>
<li><p>由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。</p>
</li>
<li><p>组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。</p>
</li>
<li><p>性能。</p>
</li>
<li><p>HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。</p>
</li>
<li><p>组合函数没有创建额外的组件实例所带来的性能损耗。</p>
</li>
</ul>
<p><strong>3.4 对比 React Hooks</strong></p>
<p>Composition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。</p>
<p>React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 <code>setup()</code> 每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 <code>setup()</code> 的闭包内。</p>
<p>也就是说，Composition API 相比 React Hooks：</p>
<ul>
<li><p>整体上更符合 JavaScript 的直觉；</p>
</li>
<li><p>Mutable 写法。</p>
</li>
<li><p>不受调用顺序的限制，可以有条件地被调用；</p>
</li>
<li><p>Hooks 需要使用下标来获取对应的 state。</p>
</li>
<li><p>不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>
</li>
<li><p>Hooks 的每次渲染都是单独的闭包。</p>
</li>
<li><p>不需要总是使用 <code>useCallback</code> 来缓存传给子组件的回调以防止过度更新；</p>
</li>
<li><p>如果给子组件传了函数，每次渲染都会被当作新 props。</p>
</li>
<li><p>不需要担心传了错误的依赖数组给 <code>useEffect/useMemo/useCallback</code> 从而导致回调中使用了过期的值。</p>
</li>
<li><p>Vue 的依赖收集是全自动的，可以做到最小粒度的更新。</p>
</li>
</ul>
<p>这都是基于 Vue 的响应式更新能力。</p>
<p>有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重：</p>
<p><a class="link"   href="https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks" >Hooks FAQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://link.zhihu.com/?target=https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/" >使用 React Hooks 声明 setInterval <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://link.zhihu.com/?target=https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" >useEffect 完整指南 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>3.5 那么它有缺点吗？</strong></p>
<p><strong>3.5.1 ref 和 reactive 的区别</strong></p>
<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>ref</th><th>reactive</th></tr><tr><td>可以处理原始值，也可以处理对象</td><td>只能处理对象</td></tr><tr><td>需要加 .value，需要考虑自动解包</td><td>不需要加 .value</td></tr><tr><td>有单独的类型</td><td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td></tr><tr><td>可以使用解构赋值</td><td>不可以使用解构赋值，会丢失响应式</td></tr><tr><td></td><td>需要使用箭头函数包装才能使用 watch</td></tr></tbody></table>

<p><strong>3.5.2 考虑响应式和 .value</strong></p>
<p>虽然写 Composition API 不会有 <code>useEffect</code> 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API 暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>面向生命周期编程 vs 面向业务逻辑编程</strong><br>Composition API 带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。<br>当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。<strong>我可以在 Vue 2 中使用吗？</strong><br>可以的，官方团队提供了可供 Vue 2 使用的插件： <a class="link"   href="https://link.zhihu.com/?target=https://github.com/vuejs/composition-api" >@vue&#x2F;composition-api <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。<br>另外他们也计划让 Composition API 在 Vue 2.7 原生支持。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://link.zhihu.com/?target=https://v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/68477600" >Vue Function-based API RFC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1x54y1V7H6/" >VueUse 作者 Anthony Fu 分享可组合的 Vue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/146097763" >深入理解 Vue3 Reactivity API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】02，事件循环</title>
    <url>/2021/02/25/someInterestingQuestions02/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>结果：打印 start promise end then1 then2 setTimeout</p>
<p>原因：简单来说，JS 代码的执行顺序为：同步代码–&gt;异步代码（微任务–&gt;宏任务）</p>
<p>分析：</p>
<ol>
<li><p>打印 start</p>
</li>
<li><p>setTimeout 加入消息队列</p>
</li>
<li><p>new Promise 的同步部分执行，打印 promise，then 部分加入消息队列</p>
</li>
<li><p>打印 end</p>
</li>
<li><p>消息队列中先处理微任务 then 的部分，打印 then1，then2</p>
</li>
<li><p>消息队列处理宏任务 setTimeout，打印 setTimeout</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2><blockquote>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" >并发模型与事件循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="http://lynnelv.github.io/js-event-loop-browser" >深入理解 js 事件循环机制（浏览器篇） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】03，浮点数</title>
    <url>/2021/03/06/someInterestingQuestions03/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>；</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - <span class="number">0.9</span> == <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型</p>
<p><code>解决方法</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>) == <span class="number">0.3</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> - <span class="number">0.9</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>) == <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><code>可以把运算封装成方法</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法函数，用来得到精确的加法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。</span></span><br><span class="line"><span class="comment">//调用：accAdd(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 加上 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accAdd</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> r1,r2,m;</span><br><span class="line">  <span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">  m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2))</span><br><span class="line">  <span class="keyword">return</span> (arg1*m+arg2*m)/m</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 add 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accAdd</span>(arg,<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//减法函数，用来得到精确的减法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。</span></span><br><span class="line"><span class="comment">//调用：accSub(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 减去 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accSub</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> r1,r2,m,n;</span><br><span class="line">  <span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">  m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2));</span><br><span class="line">  <span class="comment">//last modify by deeka</span></span><br><span class="line">  <span class="comment">//动态控制精度长度</span></span><br><span class="line">  n=(r1&gt;=r2)?<span class="attr">r1</span>:r2;</span><br><span class="line">  <span class="keyword">return</span> ((arg1*m-arg2*m)/m).<span class="title function_">toFixed</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//除法函数，用来得到精确的除法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。</span></span><br><span class="line"><span class="comment">//调用：accDiv(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 除以 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accDiv</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,r1,r2;</span><br><span class="line">  <span class="keyword">try</span>&#123;t1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;t2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params"><span class="built_in">Math</span></span>)&#123;</span><br><span class="line">    r1=<span class="title class_">Number</span>(arg1.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))</span><br><span class="line">    r2=<span class="title class_">Number</span>(arg2.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> (r1/r2)*<span class="title function_">pow</span>(<span class="number">10</span>,t2-t1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 div 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">div</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accDiv</span>(<span class="variable language_">this</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//乘法函数，用来得到精确的乘法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。</span></span><br><span class="line"><span class="comment">//调用：accMul(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 乘以 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accMul</span>(<span class="params">arg1,arg2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> m=<span class="number">0</span>,s1=arg1.<span class="title function_">toString</span>(),s2=arg2.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">try</span>&#123;m+=s1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;m+=s2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">Number</span>(s1.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))*<span class="title class_">Number</span>(s2.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))/<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 mul 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mul</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accMul</span>(arg, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;<span class="comment">//验证一下：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accAdd</span>(<span class="number">1.79</span>, <span class="number">0.12</span>));  <span class="comment">//1.91</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accSub</span>(<span class="number">2.01</span>, <span class="number">0.12</span>));  <span class="comment">//1.89</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accDiv</span>(<span class="number">0.69</span>, <span class="number">10</span>));    <span class="comment">//0.069&lt;br&gt;console.log(accMul(1.01, 1.3));   //1.313　　</span></span><br></pre></td></tr></table></figure></div>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2><ul>
<li><a class="link"   href="https://www.cnblogs.com/ppforever/p/5011660.html" >浅谈 JavaScript 浮点数及其运算 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/js/js_numbers.asp" >JavaScript 数字
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】04，逗号运算符</title>
    <url>/2021/03/14/someInterestingQuestions04/</url>
    <content><![CDATA[<!-- YCTODO -->

<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;<span class="number">6</span>,j&lt;<span class="number">5</span>,i++,j++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2>]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】05，for..in 与 for..of</title>
    <url>/2021/03/20/someInterestingQuestions05/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 此时 arr 对象的结构：[3,5,7,foo: &#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><code>for...in </code></p>
<ul>
<li>循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。</li>
<li>深入一点</li>
</ul>
<p><code>for...of </code></p>
<ul>
<li>在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。</li>
<li>首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</li>
</ul>
<p><code>Symbol.iterator</code></p>
<ul>
<li>为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</li>
<li>可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> it = myArray[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】06，进制转换</title>
    <url>/2021/03/27/someInterestingQuestions06/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">022</span> - <span class="number">017</span></span><br><span class="line"><span class="comment">// 3，18 - 15 = 3</span></span><br><span class="line"></span><br><span class="line"><span class="number">018</span> - <span class="number">045</span></span><br><span class="line"><span class="comment">// -19，18 - 37 = -19</span></span><br></pre></td></tr></table></figure></div>
<p>在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。</p>
<p>在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0xa</span>;</span><br><span class="line"><span class="comment">// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(string,radix)</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0101&#x27;</span>,<span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0101&#x27;</span>,<span class="number">8</span>) <span class="comment">// 65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">toString</span>(radix)</span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">//&quot;1010&quot; 转 2 进制</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">8</span>) <span class="comment">//&quot;12&quot; 转 8 进制</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">//&quot;a&quot; 转 16 进制</span></span><br><span class="line">(<span class="number">1000</span>).<span class="title function_">toString</span>(<span class="number">36</span>) <span class="comment">//&quot;rs&quot; 转 36 进制</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>有趣的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】01，从 createApp() 方法开始</title>
    <url>/2022/06/03/vueSourceCodeStudy01/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s0.jpg"
                      class="" title="s0"
                >
<p>PS: 这是一张很有用的图</p>
<h2 id="前言：怎样学习源码？"><a href="#前言：怎样学习源码？" class="headerlink" title="前言：怎样学习源码？"></a>前言：怎样学习源码？</h2><ol>
<li>有主线，两种方式<ol>
<li>从入口入手，package.json–&gt;</li>
<li>从逻辑入手，createApp()</li>
</ol>
</li>
<li>提出一个问题，在源码中找答案</li>
<li>学习一步整理一步，然后复盘复习（画图）</li>
<li>有所掌握后造轮子实践</li>
<li>写博客或者做视频，在知识分享中巩固知识</li>
</ol>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h2 id="首先提几个问题"><a href="#首先提几个问题" class="headerlink" title="首先提几个问题"></a>首先提几个问题</h2><ul>
<li>第一个问题：app 实例如何创建？</li>
<li>第二个问题：app 实例中有些什么？</li>
</ul>
<h2 id="第一个问题：app-实例如何创建？"><a href="#第一个问题：app-实例如何创建？" class="headerlink" title="第一个问题：app 实例如何创建？"></a>第一个问题：app 实例如何创建？</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-1.png"
                      class="" title="s1-1"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-2.png"
                      class="" title="s1-2"
                >
<p>createApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-3.png"
                      class="" title="s1-3"
                > 
<p>查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-4.png"
                      class="" title="s1-4"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-5.png"
                      class="" title="s1-5"
                >

<h2 id="第二个问题：app-实例中有些什么？"><a href="#第二个问题：app-实例中有些什么？" class="headerlink" title="第二个问题：app 实例中有些什么？"></a>第二个问题：app 实例中有些什么？</h2><p>在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-6.png"
                      class="" title="s1-6"
                >

<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">&#x27;./vueSourceCodeStudy01/myComponent&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> myPlugin <span class="keyword">from</span> <span class="string">&#x27;./myPlugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;myComponent&#x27;</span>,myComponent);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(myPlugin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3</span></span><br><span class="line"><span class="title function_">createApp</span>(&#123;...&#125;).<span class="title function_">coponent</span>(myComponent).<span class="title function_">use</span>(myPlugin).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>sourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】02，初识 mount() 方法</title>
    <url>/2022/06/03/vueSourceCodeStudy02/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上回([[vueSourceCodeStudy01]])，在 runtime-core 包下的文件<code>/runtime-core/src/apiCreateApp.ts</code>中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，<code>mount()</code>就在其中。</p>
<h2 id="首先提几个问题"><a href="#首先提几个问题" class="headerlink" title="首先提几个问题"></a>首先提几个问题</h2><ol>
<li>初次挂载时 mount() 方法做了些什么？ </li>
<li>回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s0.png"
                      class="" title="s2-0"
                ></li>
</ol>
<h2 id="初次挂载时-mount-方法干了些什么？"><a href="#初次挂载时-mount-方法干了些什么？" class="headerlink" title="初次挂载时 mount() 方法干了些什么？"></a>初次挂载时 mount() 方法干了些什么？</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-1.png"
                      class="" title="s2-1"
                >

<p>首先进入 mount() 方法，它接收 3 个参数：<code>rootContainer</code>，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到我们只传了一个字符串，是一个 CSS 选择器。</span></span><br><span class="line"><span class="title function_">createApp</span>(&#123;&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>再看方法体：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-2.png"
                      class="" title="s2-2"
                >

<p>可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。</p>
<p>让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在<code>/runtime-core/src/renderer.ts</code>目录下可以找到。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-3.png"
                      class="" title="s2-3"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-4.png"
                      class="" title="s2-4"
                >

<p>接下来找到 render() 方法的方法体：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-5.png"
                      class="" title="s2-5"
                >

<p>可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个<code>patch()</code>方法</p>
<p>我们来看一下这个 patch() 方法中传了些什么：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-6.png"
                      class="" title="s2-6"
                >

<p>可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向<code>div#app</code>，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-7.png"
                      class="" title="s2-7"
                >

<p>之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-8.png"
                      class="" title="s2-8"
                >

<!-- 
  YCNOTE：为什么 switch 语句要传入一个对象
 -->
<p>沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据<code>type</code>和<code>shapeFlag</code>的值进行不同的操作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-10.png"
                      class="" title="s2-10"
                >

<p>此时 shapeFlag 的值为 4，进行位与运算值为 true。以下<code>位移枚举</code>可以学一下，它的好处是清晰、好计算并且可以进行多值判断。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-11.png"
                      class="" title="s2-11"
                >

<p>初次挂载时执行<code>processComponent()</code>方法，进入方法体 processComponent()：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-12.png"
                      class="" title="s2-12"
                >

<p>可以看到走进 else 代码块，触发方法<code>mountComponent()</code>，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个<code>setupRenderEffect()</code>方法，</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-13.png"
                      class="" title="s2-13"
                >

<p>这个方法创建了一个执行器 <code>effect</code>，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，初次挂载时 mount() 方法执行流程大概这样：</p>
<p>mount()–&gt;createVNode()–&gt;render()–&gt;patch()–&gt;processComponent()–&gt;mountComponent()–&gt;createComponentInstance–&gt;setupRenderEffect()–&gt;ReactiveEffect()–&gt;update()–&gt;effect.run()</p>
<p>简洁一点就是：</p>
<p>mount()–&gt;render()–&gt;patch()</p>
<p>可以通过调用堆栈查看：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-14.png"
                      class="" title="s2-14"
                >

<p>回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-15.png"
                      class="" title="s2-15"
                >

<p>本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。</p>
<p>若有错误请大佬指出，感激不尽。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>sourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】03，使用渲染器来创建一个节点</title>
    <url>/2022/06/03/vueSourceCodeStudy03/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>sourceCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】03，使用渲染器来创建一个节点</title>
    <url>/2024/06/03/vueSourceCodeStudy04/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>sourceCode</tag>
      </tags>
  </entry>
</search>
